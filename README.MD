# Отчёт 

|                                                                          |        |
|-------------------------------------------------------------------------:|-------:|
|                                          Общий объём оперативной памяти  |  1.77G |
|                                                   Объём раздела подкачки |  820MB |
|                                       Размер страницы виртуальной памяти |   4096 |
|               Объём свободного физической памяти в ненагруженной системе | 1400MB |
| Объём свободного пространства в разделе подкачки в ненагруженной система |  765MB |

## Эксперимент 1
### Этап 1
#### Измерения
Основной скрипт `mem.sh` был запущен в ненагруженной системе и работал до аварийной остановки. Для снятия показаний использовался вспомогательный скрипт `scan.sh`, который раз в 10 секунд обращался к `top`.
#### Параметры системы
![plot.png](./results-1.1/plot.png)
#### Верхние 5 процессов
![top5.png](./results-1.1/top5.png)
#### `dmesg` 
```log
[ 2558.992008] Out of memory: Killed process 3448 (bash) total-vm:2545188kB, anon-rss:1591404kB, file-rss:0kB, shmem-rss:0kB, UID:0 pgtables:4612kB oom_score_adj:0
[ 2559.124810] oom_reaper: reaped process 3448 (bash), now anon-rss:0kB, file-rss:0kB, shmem-rss:0kB
```
#### `report.log | tail -1`
```
29000000
```
#### Вывод
Из графика видно, что когда память в системе закончилась, но процесс выделял её дальше, то часть его адресного пространства была перенаправлены в `swap`. Когда процесс попытался аллоцировать память, но система не смогла этого сделать, то процесс был убит.  

### Этап 2
#### Измерения
Скрипты `mem.bash` и `mem2.bash` были запущены при помощи `at`. Измерения производились аналогично эксперименту 1. 
#### Параметры системы
![plot.png](./results-1.2/plot.png)
#### Верхние 5 процессов
![top5.png](./results-1.2/top5.png)
#### `dmesg`
```log
Process2:

[10644.351588] Out of memory: Killed process 5066 (bash) total-vm:1403916kB, anon-rss:858764kB, file-rss:0kB, shmem-rss:0kB, UID:0 pgtables:2392kB oom_score_adj:0
[10644.414251] oom_reaper: reaped process 5066 (bash), now anon-rss:0kB, file-rss:0kB, shmem-rss:0kB
[10735.401061] tuned invoked oom-killer: gfp_mask=0x6200ca(GFP_HIGHUSER_MOVABLE), order=0, ...oom_score_adj=0

Process1:

[10735.451976] Out of memory: Killed process 5068 (bash) total-vm:2559840kB, anon-rss:1586492kB, file-rss:0kB, shmem-rss:0kB, UID:0 pgtables:4648kB oom_score_adj:0
[10735.563497] oom_reaper: reaped process 5068 (bash), now anon-rss:0kB, file-rss:0kB, shmem-rss:0kB
```
#### `report.log | tail -1`
```
29000000
```
#### `report2.log | tail -1`
```
15000000
```
#### Вывод
Видно, что в начале скрипты ведут себя идентично и оба аллоцируют память. Как и в прошлом эксперименте, когда память закончилась то адресное пространство обоих скриптов было частично определено в `swap`. Однако когда память закончилась, то один из процессов был убит как в прошлом эксперименте, а второй продолжил работу благодаря памяти, освободившейся после освобождения ресурсов убитого.

## Эксперимент 2
### Этап 1
#### Параметры системы
![plot.png](./results-2.1/plot.png)
![top10.png](./results-2.1/top10.png)
#### `dmesg | grep "$(cat pids.log)"`
```log
[    1.135574] NET: Registered protocol family 38
```
### Этап 2
#### Параметры системы
##### 1000000
![plot.png](./results-2.2/1000000-succ-plot.png)
##### 1250000
![plot.png](./results-2.2/1250000-succ-plot.png)
##### 1375000
![plot.png](./results-2.2/1375000-succ-plot.png)
##### 1500000
![plot.png](./results-2.2/1500000-fail-plot.png)
### Вывод
В наших эксперитах, у всех скриптов были одинаковые потребности в памяти. 
В результате стабильным максимальным значением $N$ стало `1250000`. Можно было бы ожидать его около $\frac{29000000}{30}=966,666\approx 1000000$: `При равном потреблении памяти процессами, зависимость максимально доступной памяти имеет вид `$\frac{\mathcal{C}}{N}$`, где `$N$ `- число процессов, а ` $\mathcal{C}$ `- доступтная память в системе.` Однако на деле число оказалось чуть больше, из-за того, что процессы были запущенны с интервалом в 1 секунду и более ранние заканчивали раньше, освобождая память для более поздних. Таким образом хоть сумма максимальной памяти по всем процеесам была больше доступной, но в каждый момент времени сумма текущей памяти не превышала этот лимит.
